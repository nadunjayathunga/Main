from datetime import datetime
import pandas as pd

PATH = r'C:\Masters\Data-NBNL.xlsx'
# OVERDRAFT_START_DATE: datetime = datetime(year=2020, month=11, day=1)
OVERDRAFT_START_DATE: datetime = datetime(year=2022, month=11, day=13)
START_DATE: datetime = datetime(year=2024, month=7, day=1)
END_DATE: datetime = datetime(year=2024, month=7, day=31)
OVERDRAFT_INTEREST_PCT = 0.08  # Current Overdraft Interest

# Finance/MIS Reports/Voucher Details/Job Report with Service Elements
df_data: pd.DataFrame = pd.read_excel(io=PATH, sheet_name='fData',
                                      usecols=['Voucher_Date', 'Ledger_Code', 'Job_Code', 'Credit', 'Type',
                                               'Voucher Number', 'Debit'])
df_coa: pd.DataFrame = pd.read_excel(io=PATH, sheet_name='dCoAAdler',
                                     usecols=['Ledger_Code', 'Header', 'Ledger Name', 'Second Level Group Name'])
# Finance/MIS Reports/GL Dump/GL Dump
df_gl: pd.DataFrame = pd.read_excel(io=PATH, sheet_name='fGL',
                                    usecols=['Voucher Date', 'Amount', 'Ledger Code', 'Ledger Name', 'Cost Center'])
df_gl['Cost Center'] = df_gl['Cost Center'].str.split(
    '|', expand=True)[0].str.strip()  # NBNL0096 | Abduelmotlib Babiker
# Finance/MIS Reports/Receipts Details/Customer Invoice Wise Payment Performance
df_collection: pd.DataFrame = pd.read_excel(io=PATH,
                                            usecols=['Ledger Code', 'Invoice Number', 'Invoice Amount',
                                                     'Payment Voucher Number', 'Payment Date',
                                                     'Invoice Date'],
                                            sheet_name='fCollection', date_format={'Invoice Date': '%d-%b-%y'},
                                            dtype={
                                                'Payment Voucher Number': 'str'},
                                            index_col='Invoice Number')
# Logistics/MIS Reports/Exceptions Reports/Customer Invoice-Not Prepared
df_notinvoiced: pd.DataFrame = pd.read_excel(io=PATH,
                                             usecols=[
                                                 'Job Number', 'Sales Rate', 'Voucher Date'],
                                             sheet_name='fNotInvoiced')
df_merged: pd.DataFrame = pd.merge(
    left=df_data, right=df_coa, how='left', on='Ledger_Code')
df_merged['Net'] = df_merged['Credit'] - df_merged['Debit']

df_jobs: pd.DataFrame = pd.read_excel(io=PATH, sheet_name='dJobs', usecols=[
                                      'Job_Number', 'Customer_Code'])

df_jobs['Job_Number'] = df_jobs['Job_Number'].str.split(
    '-', expand=True)[0].str.strip()  # NBNLSIFC240015-Rev1

df_jobs.drop_duplicates(subset=['Job_Number'], keep='first', inplace=True)
df_jobs.set_index(keys='Job_Number', inplace=True)

# exclusions includes customers and staff relates to Al Ruwais Port Operations.
exclusion: dict = {'customers': ['CUS0794', 'CUS0781', 'CUS0787', 'CUS0613', 'CUS0756','CUS0813'],
                   'staff': ['NBNL0095', 'NBNL0096', 'NBNL0106']}


def supplier_payments(df_merged: pd.DataFrame, job_id: str) -> pd.DataFrame:
    """This will return a dataframe containing all sundry purchase (SP) and Payment Request (PR) raised against a job
    number

    Args:
        df_merged (pd.DataFrame): Finance / Voucher Details / MIS Reports Job report with service Element from the begenning
        job_id (str): An individual job number

    Returns:
        pd.DataFrame: The final df contains Voucher Date and the sum of each voucher [Voucher_Date|Credit]
    Voucher_Date Voucher Number   Credit
0   2024-02-01   NBL/PR240040     5.00
1   2024-02-04   NBL/SP240445  2413.55
2   2024-02-17   NBL/PR240035   475.00
3   2024-02-17   NBL/PR240037   730.00
    """

    df_merged = df_merged.loc[(df_merged['Type'].isin(['SP', 'PR', 'DN'])) &
                              (df_merged['Job_Code'] == job_id) &
                              df_merged['Header'].isin(['Accounts Payable', 'Cash in Hand', 'NBKH - R/P', 'NBNH - R/P'])]
    df_merged = df_merged.groupby(
        by=['Voucher_Date', 'Ledger_Code', 'Job_Code', 'Voucher Number'], as_index=False).sum()
    df_merged = df_merged.loc[:, ['Voucher_Date', 'Voucher Number', 'Net']]
    df_merged.rename(columns={'Net': 'Credit'}, inplace=True)
    return df_merged


def salary_payments(df_merged: pd.DataFrame, job_id: str) -> pd.DataFrame:
    """for a given job_id take the months to which net revenue has been recorded. 
    Apportion direct salary cost based on individual stream revenue generated by a month to that stream's total revenue of the month 

    Args:
        df_merged (pd.DataFrame): merged df_data and df_coa
        job_id (str): individual job id

    Returns:
        pd.DataFrame: salary cost recorded based on net revenue of each stream and month
            Voucher_Date   Credit Voucher Number
        0   2023-08-31  93.179847  Salary of Aug
    """

    # Types of revenue relates to a given job. i.e customs/freight/transport
    filt_net_rev = (df_merged['Header'] == 'Logistics Revenue') & (
        df_merged['Job_Code'] == job_id)
    # convert Voucher_Date to the last date of the month
    df_merged = df_merged.loc[filt_net_rev]
    df_merged.loc[:, 'Voucher_Date'] += pd.offsets.MonthEnd(0)
    df_merged = df_merged.groupby(
        by=['Voucher_Date', 'Ledger_Code'], as_index=False).sum()
    df_merged = df_merged.loc[df_merged['Net'] !=
                              0, ['Ledger_Code', 'Voucher_Date', 'Net']]
    # ['Ledger_Code', 'Voucher_Date','Net'] # any job id can potentially have maximum three rows
    # and if the job id has multiple invoices raised in different period the number of rows can increase with different voucher dates
    if not df_merged.empty:
        # Apportioned salary cost based on total revenue and total direct salary cost.
        # for each row of revenue stream this function will calculate apportioned salary cost
        # column name was named as "Credit" to keep the consistancy with the other dataframes that going to concat later stage using concat_dataframe()
        df_merged['Credit'] = df_merged.apply(
            salary_allocation, axis=1, args=[job_id])
        df_merged.drop(columns=['Ledger_Code', 'Net'], inplace=True)
        # to group the salary cost apportioned for each revenue stream.
        df_merged = df_merged.groupby(
            by=['Voucher_Date'], as_index=False).sum()
        # create a narration for each salary allocation based on the month name.
        # Voucher number is not necessary for final outcome but for debugging purpose.
        df_merged['Voucher Number'] = df_merged.apply(
            salary_description, axis=1)
        return df_merged
    else:
        return pd.DataFrame()


def receipts_recorded(df_merged: pd.DataFrame, df_collection: pd.DataFrame, job_id: str) -> pd.DataFrame:

    # list of invoices raised for a given job id
    inv_filt = (df_merged['Type'] == 'SI') & (df_merged['Job_Code'] == job_id)
    invoices_list: list = df_merged.loc[inv_filt,
                                        'Voucher Number'].unique().tolist()
    # Payment Voucher Number is null mean the invoice has not yet been settled. Below will list all the invoices that
    # has been settled partially or fully
    df_collection: pd.DataFrame = df_collection.loc[df_collection['Payment Voucher Number'].notnull(
    )]
    # out of all the invoices raised for a given job id, take only invoices which were settled partially or fully
    settled_invoices: list = [
        invoice for invoice in invoices_list if invoice in df_collection.index]
    if settled_invoices:  # do below only if a job id has fully or partially settled invocies
        df_collection = df_collection.loc[settled_invoices, [
            'Payment Voucher Number', 'Payment Date']]
        settlement_df_final = pd.DataFrame()
        for invoice in df_collection.index:  # for those invoices which were fully/partially settled
            voucher_number: list = []
            voucher_date: list = []
            voucher_amount: list = []
            settlement_df = pd.DataFrame()
            receipts = df_collection.loc[invoice,
                                         'Payment Voucher Number'].split(sep=';')  # NBL/CN200002-1159.00;NBL/RV210534-672.00 -> ['NBL/CN200002-1159.00','NBL/RV210534-672.00']
            voucher_number = [voucher.split(sep='-')[0]
                              for voucher in receipts]  # ['NBL/CN200002-1159.00','NBL/RV210534-672.00'] -> ['NBL/CN200002','NBL/RV210534']
            voucher_amount = [-float(voucher.split(sep='-')[1])
                              for voucher in receipts]  # ['NBL/CN200002-1159.00','NBL/RV210534-672.00'] -> [-1159.00,-672.00]
            # 6/21/2021
            if isinstance(df_collection.loc[invoice, 'Payment Date'], datetime):
                voucher_date.append(df_collection.loc[invoice, 'Payment Date'])
            else:
                voucher_date = [
                    date for date in df_collection.loc[invoice, 'Payment Date'].split(sep=',')]  # 02-Nov-2020,08-Feb-2021 -> ['02-Nov-2020','08-Feb-2021']
            settlement_df: pd.DataFrame = pd.DataFrame(
                data={'Voucher Number': voucher_number, 'Voucher_Date': voucher_date, 'Credit': voucher_amount})
            settlement_df['Voucher_Date'] = pd.to_datetime(
                settlement_df['Voucher_Date'], format='%d-%b-%Y')  # in case the date is not formatted as datetime object
            settlement_df_final = pd.concat(
                [settlement_df_final, settlement_df])
        # this will return df with columns ['Voucher Number','Voucher_Date','Credit'] for all the invoices either fully or partially settled
        return settlement_df_final
    else:
        pass


def salary_description(row):
    """This function is used to create a narration for salary calculated for each month

    Args:
        row (_type_): row returned by salary_payment()

    Returns:
        _type_: narration in following format "Salary of {Dec}"
    """
    voucher_date: datetime = row['Voucher_Date']
    month_short_name = voucher_date.strftime('%b')
    return f'Salary of {month_short_name}'


def salary_allocation(row, job_id: str) -> float:
    """Takes a row returned by salary_payments() and return 

    Args:
        row (_type_): a row returned by salary_payment()

    Returns:
        float: Apportioned salary cost based on total revenue and total direct salary cost
    """

    ledger: int = row['Ledger_Code']
    end_date: datetime = row['Voucher_Date']
    # total net revenue and total salary cost calculated for a given revenue stream and for a given month.
    total_revenue, total_salary_cost = revenue_totals(
        ledger=ledger, end_date=end_date, df_merged=df_merged, df_gl=df_gl, job_id=job_id)
    if total_revenue != 0:
        # take monthwise job id wise ,streamwise revenue, divide it by that month total revenue for that stream and
        #  then multiply by salary cost for that stream for that month
        return row['Net'] / total_revenue * total_salary_cost
    else:
        return 0


def revenue_totals(ledger: int, end_date: datetime, df_merged: pd.DataFrame, df_gl: pd.DataFrame, job_id: str) -> tuple:
    """Get a single row generated by salary_allocation() and calculate  total revenue and total salary cost

    Args:
        ledger (int): Freight/Custom or Transport revenue ledger row for a given job id in df_data [Ledger Code]
        end_date (datetime): Freight/Custom or Transport revenue ledger row for a given job id in df_data [Voucher No] as last date of the month for each date
        df_merged (pd.DataFrame): merged dataframe of df_data and df_coa
        df_gl (pd.DataFrame): general ledger for the whole period

    Returns:
        tuple: total net revenue for a givne month for a given revenue stream (i.e Transportation for 01-11-2023 till 30-11-2023) - total_revenue
                total direct salary cost for a givne month for a given revenue stream (i.e Transportation for 01-11-2023 till 30-11-2023) - total_salary_cost
    """
    customer_code: str = df_jobs.loc[job_id, 'Customer_Code']

    start_date: datetime = end_date.replace(
        day=1)  # as end date is always last date of each month
    # list of direct salary ledgers for a given revenue stream (i.e Salaries Expense - Transport-> ['Employee Benefits - Transport','Salaries Expense - Transport'])
    cost_ledgers: list = account_map(ledger=ledger, df_coa=df_coa)

    if customer_code in exclusion['customers']:
        # for those customers are related to Al Ruwais Operations, it is required to allocate the salary cost for those employees who work exclusively work
        # for that operations details to which can be found in exclusions dictionery.
        job_ids: list = df_jobs.loc[df_jobs['Customer_Code'].isin(
            exclusion['customers'])].index.to_list()
        # job ids relates to customers mentioned in the exclusions dictionery
        net_revenue_filt = (df_merged['Voucher_Date'] >= start_date) & (df_merged['Voucher_Date'] <= end_date) & (
            df_merged['Ledger_Code'] == ledger) & (df_merged['Job_Code'].isin(job_ids))  # start_date & end_date for a given month 01/11/2023 & 30/11/2023
    # total net revenue for a givne month for a given revenue stream (i.e Transportation for 01-11-2023 till 30-11-2023)
        salary_cost_filt = (df_gl['Voucher Date'] >= start_date) & (df_gl['Voucher Date'] <= end_date) & (
            df_gl['Ledger Code'].isin(cost_ledgers)) & (df_gl['Cost Center'].isin(exclusion['staff']))
        # exclusions['staff'] is a list which contains employees who are working exclusively for Al Ruwais Operations.
    else:
        # for those customers who are not part of Al Ruwais Operations
        net_revenue_filt = (df_merged['Voucher_Date'] >= start_date) & (df_merged['Voucher_Date'] <= end_date) & (
            df_merged['Ledger_Code'] == ledger) & (df_merged['Job_Code'].isin(df_jobs.loc[~df_jobs['Customer_Code'].isin(exclusion['customers'])].index.to_list()))
        salary_cost_filt = (df_gl['Voucher Date'] >= start_date) & (df_gl['Voucher Date'] <= end_date) & (
            df_gl['Ledger Code'].isin(cost_ledgers)) & (~df_gl['Cost Center'].isin(exclusion['staff']))  # total direct salary cost for a given month for a
    # given revenue stream (i.e Transportation for 01-11-2023 till 30-11-2023)

    total_revenue: float = df_merged.loc[net_revenue_filt, 'Net'].sum()
    total_salary_cost: float = df_gl.loc[salary_cost_filt, 'Amount'].sum()

    return (total_revenue, total_salary_cost)


def account_map(ledger: int, df_coa: pd.DataFrame) -> list:
    """This function is used to derive the headers for revenue/salaries cost with direct cost salary ledger code. 

    Args:
        ledger (int): ledger code 

    Returns:
        list: output similar to [5010201002, 5010201005]
    """
    df_coa.set_index('Ledger_Code', inplace=True)
    # Salaries Expense - Transport
    ledger_name: str = df_coa.loc[ledger, 'Ledger Name']
    ledger_name = ledger_name.split(sep='-')[1].strip()  # Transport
    cost_filt = df_coa['Ledger Name'].str.contains(ledger_name) & (
        df_coa['Header'] == 'Staff Cost - Logistics')
    cost_ledgers: list = df_coa[
        cost_filt].index.to_list()  # list of direct cost salaries applicable for a given revenue
    df_coa.reset_index(inplace=True)
    return cost_ledgers


def concat_dataframe(*args) -> pd.DataFrame:
    """accepts dataframes i.e df returned by supplier_payments(), salary_payments() and receipts_recorded()

    Returns:
        pd.DataFrame: concatenated dataframe made out of arguments
    """
    combined = pd.concat([*args])
    # As this is required in getting days difference while caculating overdraft interest
    combined.sort_values(by='Voucher_Date', ascending=True, inplace=True)
    # take only those transactions happened after overdraft facility was taken.
    period_filt = (combined['Voucher_Date'] >= OVERDRAFT_START_DATE) & (
        combined['Voucher_Date'] <= END_DATE)
    combined = combined.loc[period_filt]
    # as concatenated dataframe has mixed indexed inherited from their own dataframes.
    combined.reset_index(inplace=True, drop=True)
    # to have the running totol of transactions
    combined['CumTotal'] = combined['Credit'].cumsum()
    return combined


def receipts_till_date(dataframe: pd.DataFrame, current_date: datetime) -> float:
    """Returns sum of total receipts recorded until current iteration 

    Args:
        dataframe (pd.DataFrame): _description_
        current_date (datetime): current voucher date

    Returns:
        float: sum of receipts recorded till date
    """
    try:
        return dataframe.loc[dataframe['Voucher_Date'] <= current_date, 'Credit'].sum() * -1
    except:
        return 0


def tiv(job_id: str, df_merged: pd.DataFrame, df_notinvoiced: pd.DataFrame) -> float:
    """Total Invoice Value (tiv) This is the total gross amount invoiced and value of the service elements not invoiced. 

    Args:
        job_id (str): job id currently under evaluation 
        df_merged (pd.DataFrame): merged df_data and coa dataframe
        df_notinvoiced (pd.DataFrame): _Customer Invoice-Not Prepared

    Returns:
        float: value of the invoiced service elements and service elements not yet invoiced but supplier payment has been made. 
    """
    # Total of service elements already invoiced for a given job. Transaction Type "Sales Invoice"  Prefix is "SI" and
    # ledger account to which debit side of the entry is either "Trade Receivable" or "Due from related party"
    invoiced: float = df_merged.loc[(df_merged['Type'].isin(['SI'])) & (df_merged['Voucher_Date'] <= END_DATE) & (df_merged['Job_Code'] == job_id) &
                                    df_merged['Second Level Group Name'].isin(
        ['Trade Receivables', 'Due from Related Parties']), 'Net'].sum() * -1
    # value of the service elements where supplier invoice has been paid but not yet raised the customer invoice
    uninvoiced: float = df_notinvoiced.loc[(
        df_notinvoiced['Job Number'] == job_id) & (df_notinvoiced['Voucher Date'] <= END_DATE), 'Sales Rate'].sum()
    return invoiced + uninvoiced


def od_interest(dataframe: pd.DataFrame, receipt_df: pd.DataFrame, tiv: float) -> pd.DataFrame:
    """_summary_

    Args:
        dataframe (pd.DataFrame): _description_
        receipt_df (pd.DataFrame): _description_
        tiv (float): _description_

    Returns:
        pd.DataFrame: _description_
    """
    interest: list = []

    if not dataframe.empty:
        # job_data is concatenated dataframe returned by concat_dataframe()
        job_data: pd.DataFrame = dataframe
        last_transaction_date: datetime = job_data.iloc[-1]['Voucher_Date']
        last_cum_balance: float = job_data.iloc[-1]['CumTotal']
        days_since_last_tran: int = (END_DATE - last_transaction_date).days
        final_interest: float = 0
        for idx, _ in job_data.iterrows():
            current_date: datetime = job_data.loc[idx, 'Voucher_Date']

            receipts_till: float = receipts_till_date(
                dataframe=receipt_df, current_date=current_date)

            if tiv >= receipts_till:
                if len(job_data) == 1:
                    amount = last_cum_balance * days_since_last_tran * OVERDRAFT_INTEREST_PCT / 360
                    interest.append(amount)
                if idx > 0:
                    previous_date: datetime = job_data.loc[(
                        idx - 1), 'Voucher_Date']
                    days_diff: int = (current_date - previous_date).days
                    amount: float = job_data.loc[(
                        idx - 1), 'CumTotal'] * days_diff * OVERDRAFT_INTEREST_PCT / 360
                    interest.append(amount)
        interest: float = sum([i for i in interest if i > 0])
        if tiv > receipts_till:
            if len(job_data) != 1:
                final_interest = last_cum_balance * days_since_last_tran * OVERDRAFT_INTEREST_PCT / \
                    360 if (last_cum_balance * days_since_last_tran *
                            OVERDRAFT_INTEREST_PCT / 360) > 0 else 0
        interest += final_interest
    else:

        interest = 0
    return round(number=interest, ndigits=2)


def job_interest(row) -> tuple:
    """Calculate interest until a given date and the investment made until a given date for a given job. 

    Args:
        row (_type_): a row in the report

    Returns:
        tuple: Calculated interest and investment
    """
    job_id = row['Job_Code']
    supplier: pd.DataFrame = supplier_payments(
        df_merged=df_merged, job_id=job_id)
    salary: pd.DataFrame = salary_payments(
        df_merged=df_merged, job_id=job_id)
    receipts = receipts_recorded(
        df_merged=df_merged, df_collection=df_collection, job_id=job_id)
    gross_inv: float = tiv(
        job_id=job_id, df_merged=df_merged, df_notinvoiced=df_notinvoiced)
    combined: pd.DataFrame = concat_dataframe(supplier, salary, receipts)
    investment: float = concat_dataframe(supplier, salary)['Credit'].sum()
    interest: float = od_interest(
        dataframe=combined, receipt_df=receipts, tiv=gross_inv)
    return (interest, investment)


def total_interest(jobs: list) -> float:
    total_interest: float = 0
    for job in jobs:
        supplier: pd.DataFrame = supplier_payments(
            df_merged=df_merged, job_id=job)
        salary: pd.DataFrame = salary_payments(
            df_merged=df_merged, job_id=job)
        receipts = receipts_recorded(
            df_merged=df_merged, df_collection=df_collection, job_id=job)
        gross_inv: float = tiv(
            job_id=job, df_merged=df_merged, df_notinvoiced=df_notinvoiced)
        combined: pd.DataFrame = concat_dataframe(supplier, salary, receipts)
        interest: float = od_interest(
            dataframe=combined, receipt_df=receipts, tiv=gross_inv)
        total_interest += interest
    return total_interest